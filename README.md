# leetcode刷题总结

### 双指针

#### 快慢指针

###### 说明：

使用具有 不同速度 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指针每次移动一步，而快指针每次移动两步。

###### 解决问题：

1. 判断链表是否有环。(141题)

###### 变形：

1. Floyd 算法：判断是否有环，并找出入环点。（142题）

#### 同速双指针

###### 解决的问题

1. 同位不同链：找出俩链表相交节点。（160题）
2. 同链不同位：删除链表的倒数第N个节点。（19题）

### 递归

###### 解决的问题

1. 反转链表。（206题）

### 哨兵节点

###### 说明

哨兵节点广泛应用于树和链表中，如伪头、伪尾、标记等，它们是纯功能的，通常不保存任何数据，其主要目的是使链表标准化，如使链表永不为空、永不无头、简化插入和删除。

###### 解决问题：

1. 简化移除链表元素中要移除的元素是头元素的情况。（203题）

### 栈和队列

###### 栈辅助经行深度优先搜索。

###### 队列辅助进行广度优先搜索

### 原地记忆操作

1. 用矩阵首行首列记忆数据。（01.08题）

### 增加标志位

1. 增加正负标准位。（498题）



### 动态规划

##### 思考步骤

###### 1、 思考状态（重点）

状态的定义，先尝试「题目问什么，就把什么设置为状态」；

然后思考「状态如何转移」，如果「状态转移方程」不容易得到，尝试修改定义，目的依然是为了方便得到「状态转移方程」

「状态转移方程」是原始问题的不同规模的子问题的联系。即大问题的最优解如何由小问题的最优解得到。

###### 2、思考状态转移方程（核心、难点）

状态转移方程是非常重要的，是动态规划的核心，也是难点；

常见的推导技巧是：分类讨论。即：对状态空间进行分类；

归纳「状态转移方程」是一个很灵活的事情，通常是具体问题具体分析；

除了掌握经典的动态规划问题以外，还需要多做题；

如果是针对面试，请自行把握难度。掌握常见问题的动态规划解法，理解动态规划解决问题，是从一个小规模问题出发，逐步得到大问题的解，并记录中间过程；

「动态规划」方法依然是「空间换时间」思想的体现，常见的解决问题的过程很像在「填表」。

###### 3、思考初始化

初始化是非常重要的，一步错，步步错。初始化状态一定要设置对，才可能得到正确的结果。

角度 1：直接从状态的语义出发；

角度 2：如果状态的语义不好思考，就考虑「状态转移方程」的边界需要什么样初始化的条件；

角度 3：从「状态转移方程」方程的下标看是否需要多设置一行、一列表示「哨兵」（sentinel），这样可以避免一些特殊情况的讨论。

###### 4、思考输出

有些时候是最后一个状态，有些时候可能会综合之前所有计算过的状态。

###### 5、思考优化空间（也可以叫做表格复用）

「优化空间」会使得代码难于理解，且是的「状态」丢失原来的语义，初学的时候可以不一步到位。先把代码写正确是更重要；
「优化空间」在有一种情况下是很有必要的，那就是状态空间非常庞大的时候（处理海量数据），此时空间不够用，就必须「优化空间」；
非常经典的「优化空间」的典型问题是「0-1 背包」问题和「完全背包」问题。

##### 典型问题

1. 第5题 求最大回文串。

###  "自顶向下"的解决方案

"自顶向下"意味着在每个递归层次上，我们首先访问节点以获得一些值，然后在调用递归函数时，将这些值传给其子节点。

### "自底向上"的解决方案

"自底向上" 意味着在每个递归层次上，我们首先为每个子节点递归地调用函数，然后根据返回值和根节点本身的值给出相应结果。

### KMP算法

它的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。它的时间复杂度是 O(m+n))。

###### 解决问题

1. 28题 字符串匹配。

# C++边刷边学典型语法记录

### 广义表赋值

`vector<vector<int>>test(row);`

`for(int i=0;i<row;i++)`

`	test[i]=vector<int>(cow,val);`

### 数值切割

`vector<int> cutting(vector<int>& input){`

`vector<int> leftoutput(input.begin(),input.begin()+index);`

`vector<int> rightoutput(input.begin()+index,input.end());`

`}`

### 将int转化为string

`string transfer(vctor<int> test){`

`ostringstream s;`

`for(int i=0;i<test,size();i++){`

`s << test[i];`

`}`

`return s.str();` 

`}`

### 将string转化位int

`stringstream s;`

`int number;`

`s << string `

`s >> number`

